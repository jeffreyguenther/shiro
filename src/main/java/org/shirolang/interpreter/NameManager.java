/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

package org.shirolang.interpreter;

import org.shirolang.exceptions.NameUsedException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

/**
 * This class manages the names generated by the runtime
 * 
 * //TODO Adapt this class to use NameGenerators. Associate a NameGenerator
 * per type of object being named.
 * @author jeffreyguenther
 */
public class NameManager {
    private final Map<String, Integer> nextCounter;
    private final Map<String, Set<String>> instanceNames;

    /**
     * Default constructor
     */
    public NameManager() {
        nextCounter = new HashMap<>();
        instanceNames = new HashMap<>();
    }

    /**
     * Saves a name
     * @param type type of the object to save the name
     * @param name name to save
     * @throws NameUsedException if the name is already used in the name manager
     */
    public void saveName(String type, String name) throws NameUsedException {
        if(isUsed(name)){
            throw new NameUsedException(name + " is already used.");
        }

        // initialize the add
        instanceNames.putIfAbsent(type, new HashSet<>());
        instanceNames.get(type).add(name);
    }

    /**
     * Generates a name
     * @param type type of the object to generate name for
     *             TODO add the ability to customize generators
     * @return a new name for the given type. The current format
     * is lowercase type with the next available counter appended
     * For example, for the first name generated for type "Point", you would get
     * "point1". If the name is already used, the generator increments the counter
     * and creates a new name candidate.
     */
    public String generateName(String type){
        String name = type.toLowerCase() + incrementCount(type);

        if(isUsed(name)){
            name = generateName(type);
        }

        return name;
    }

    /**
     * Checks if a name is already used
     * @param name name to check
     * @return true if the name is used, otherwise false
     */
    public boolean isUsed(String name){
        return getNames().contains(name);
    }

    /**
     * Gets the names for a type
     * @param type type to get the names for
     * @return the add of names associated with the given type
     */
    public Set<String> getNames(String type){
        return instanceNames.get(type);
    }

    /**
     * Gets all of the names used by all types
     * @return names for all of the types
     */
    public Set<String> getNames(){
        Set<String> allNames = new HashSet<>();
        for(Set<String> names: instanceNames.values()){
            allNames.addAll(names);
        }

        return allNames;
    }
    
    /**
     * Clears all names and instance counts from the manager.
     * All instance counts are add to zero
     */
    public void reset(){
        nextCounter.clear();
        instanceNames.clear();
    }
    
    /**
     * Increments the number of instances of the type
     * @param type type to increment
     * @return current number of instances of the type
     */
    private int incrementCount(String type){
        // get the count of instances for the passed type
        Integer count = nextCounter.get(type);
        
        // if no instances exist yet
        if(count == null){
          count = 0;   
        }
        
        count++;
        nextCounter.put(type, count);
        return count;
    }
}
